LinkedList
리스트를 만드는 방법중에 하나.

Linked = 연결

그 전에 알아야 할 것
CPU - 가장 빠르다
Memory - 가격이 비싸다, 용량이 적다, 전원이 꺼지면 데이터가 사라진다, 스토리지에 비해 빠르다.
Storage(HDD/SSD) - 데이터를 저장하는 역할, 가격 저렴, 용량이 크다, 전원이 꺼져도 데이터가 저장된다.

CPU가 Storage에서 직접 데이터를 가져다 쓰기에는 너무 느리다. 때문에 스토리지의 데이터를 메모리로 옮겨놓고 CPU는 메모리의 데이터를 활용한다.

데이터스트럭쳐와 밀접하게 연관되어있는 것은 메모리이다.

메모리를 효율적으로 사용하는 것이 데이터 스트럭쳐의 미션 또는 역할이다.

메모리를 건물에 비유해보자

건물에는 여러 사무실이 있고 각각의 사무실에는 주소(address)가 있다.
메모리에도 데이터가 저장되어있는 각각의 위치에 주소가 있다.
각각의 주소에 접근할 때 걸리는 시간이 동일하다는 특성을 가지고 있다.
이러한 메모리를 Random Access Memory라고 하며 줄여서 RAM이라고 부른다.
찾고자 하는 데이터의 주소를 알고있다면 빠른 속도로 데이터를 가지고 올 수 있다는 것이 RAM의 주요한 특징이다.
이러한 특징을 활용했을때 빠른 애플리케이션을 구현할 수 있다.

ArrayList는 array를 사용한다. 각 엘리먼트들이 메모리 공간의 연속적인 주소를 갖는다.
LinkedList는 각 엘리먼트들이 비 연속적인 주소를 가지고 있지만 서로 연결되어있다.

LinkedList의 구조
연결 되어있다는 특성을 가지고 있기 때문에 엘리먼트라는 용어대신에 노드(node) 혹은 버텍스(vertex)라는 용어를 사용한다.

노드는 마디, 교점을의미하고 버텍스는 정점, 꼭지점을 의미한다.(연결과 연관되어있는 개념)

노드를 표현할 때에는 C언어의 경우 구조체를 사용하고 객체지향언어의 경우 객체를 활용하는 것이 일반적인 경우이다.

노드 안에는 두개의 필드(변수)가 있다. 첫번째 변수는 데이터 필드로 실제값을 저장한다.
두번째 변수는 링크 필드로 해당 노드의 다음 노드가 무엇인지 알기위해서 다음 노드에 대한 정보가 저장되어있다.

LinkedList를 이용하기 위해서는 첫번째 노드가 무엇인지 알아야한다.
첫번째 노드가 무엇인가를 의미하는 정보를 헤드 필드에 저장한다. 

http://visualgo.net

head(first) 누가 리스트의 시작인가를 저장하는 변수

next = 다음 노드가 무엇인지를 저장하는 노드 내부의 변수


vertex의 next변수에 head변수를 대입하면 해당 vertex의 next는 기존의 head가 가리키던 객체를 가리키게 된다. 

이후 head에 위의 vertex에 대한 정보를 대입하면 head는 위의 vertex를 가리킨다.

중간에 노드 추가하기
1) linkedlist의 head를 변수 temp1에 저장한다.
2) 노드를 추가하고자 하는 인덱스를 변수k에 대입하고 0이 아닐때까지 k를 감소시키며(--k) temp1에 temp1.next를 대입하는 작업을 반복한다.
3) k가 0이면 현재 temp1.next를 변수 temp2에 대입한다.
4) 추가하고자 하는 값을 가진 새로운 변수 newVertex를 생성한다.
5) temp1.next에 newVertex를 대입한다.
6) newVertex.next에 temp2를 대입한다.

노드(버텍스) 삭제하기
1) linkedlist의 head를 변수 current에 저장한다.
2) 노드를 삭제하고자 하는 인덱스를 변수 k에 대입하고 0이 아닐때까지 k를 감소시키며(--k) current에 current.next를 대입하는 작업을 반복한다.
3) k가 0이면 현재 current.next를 변수 tobedeleted에 대입한다. (바로 삭제하지 않는다.)
(바로 삭제하면 삭제한 노드 이후의 노드를 찾을 수 없다.)
4) current.next에 current.next.next를 대입한다.
5) tobedeleted를 삭제한다.

arraylist와 linkedlist 비교
1) arraylist는 인덱스를 이용하여 조회시 random access가 가능하기 때문에 조회가 빠르다.
2) linkedlist는 앞의 노드에게 다음의 노드를 물어야 하기 때문에 특정 위치의 데이터를 조회하는 것이 느리다.
3) arraylist의 경우 추가/삭제 시 빈칸을 만들거나 채우기 위해 뒤의 element들을 밀거나 당겨야 하므로 느리다.
4) linkedlist는 추가/삭제 시 앞과 뒤의 element들의 next값만 바꾸면 되므로 빠르다.
5) linkedlist는 포인터 또는 참조값으로 각각의 노드가 연결되어있으므로 메모리가 허용하는한에서는 노드를 무한대로 키울 수 있다. 즉, list의 크기가 확정적이지 않다.
6) arraylist는 배열을 내부적으로 활용하고 있기 때문에 array의 크기를 넘어서면 error를 발생시키는 단점이 있다.
7) 저장할 데이터보다 큰 arraylist를 만든다면 나머지 공간만큼의 낭비가 발생한다.
